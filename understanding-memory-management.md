---
title: "Understanding Memory Management"
author: Dipesh Kafle
theme: "metropolis"
fontsize: 10pt
lang: en-US
section-titles: true
colorlinks: true
linkcolor: blue
urlcolor: red
header-includes: |
  \usepackage{fancyhdr}
  \pagestyle{fancy}
  \usepackage{setspace}
  \usepackage{graphicx}
  \usepackage{amsfonts}
  \usepackage{amssymb}
  \usepackage{amsmath}
  \usepackage{minted}
---

\setsansfont[ItalicFont={Fira Sans Light Italic},%
BoldFont={Fira Sans SemiBold},%
BoldItalicFont={Fira Sans Italic}]%
{Fira Sans Light}%

## Memory Layout

![A program's memory segments roughly classified](images/memory.png){width=50%}

- In practice, the stack grows towards lower addresses, the heap towards
  higher(the diagram has it the other way around, but that doesn't matter).

\pause

- What are all these things ??

\pause

- We are mainly concerned withe the stack and the heap for the purpose of this
  talk, but we'll see what the other things are as well.

## Code and Static segments

- **Code**: Generated target code has a fixed size, allowing it to be stored in a statically determined area called Code, usually at the low end of memory.

\pause

- **Static**: Statically determined data objects, such as global constants and data generated by the compiler at compile time, can be stored in another area called Static.

\pause

\scriptsize

```c
const char* s = "Lorem Ipsum something something";
int main(){
  const char* string_arr[] = {"Made", "with", "love", "by", "Delta", "Force"};
  return 0;
}
```

\normalsize

All the strings used in the above code segment are stored in static section,
while the instructions generated for the program will be in code section.

## Stack and Stack Allocation

- The stack will store things such as local variables, return address from a
  function call, etc.

\scriptsize

```c
int main(){
  int a = 10; // This is doing stack allocation
  int b = 20;
  int arr[2] = {1,2};
  return 0;
}
```

\normalsize

![Stack Layout for above code](images/stack_layout.png){width=50%}

## Heap and Heap Allocation

- Many programming languages allow the programmer to allocate and deallocate
  data under program control.

\pause

- The heap is used to manage long-lived data.

\pause

- C/C++ has \texttt{malloc/realloc/free} functions for doing heap memory management.

\pause

- Unavoidable when we want to allocate memory whose size is known only when
  the program is running(dynamic allocation).

\pause

\scriptsize

```c
int* f(int n){
  return malloc(n*sizeof(int));
}
int main(){
   int n ;
   scanf("%d", &n);
   int *arr = f(n); // arr is heap allocated,returned from call to f
   free(arr); //Since, we're good programmers, we'll free the memory as well.
}
```

\normalsize

## What exactly are malloc/realloc/free?

Heap allocation functions:

- \texttt{\textcolor{red}{malloc(x)} }: allocate `x` bytes in heap

\pause

- \texttt{\textcolor{red}{ realloc(p, x) }}: resize previously allocated heap memory

\pause

- \texttt{\textcolor{red}{ free(p) } }: return heap memory to the operating system

# Introduction to Memory Management

- Memory management is all about using \texttt{heap memory} correctly.

\pause

- If it's done incorrectly, the program can \textcolor{red}{crash } or \textcolor{red}{slow down}.

\pause

- Stack allocations don't need to be freed; they're automatically managed with **scopes** (we'll talk about scopes in the next slide).

\pause

- There are different techniques for managing heap memory.

### Important terminology

- \textbf{\textcolor{red}{Memory Leak}}: It happens when you ask the operating system for memory but
  don't return it back.

## What is this scope thing??

\scriptsize

```cpp
// NOTE: This function won't compile
int f(){ // scope '1 starts
    int a = 10;
    { // scope '2 starts
       int b = 20;
    } // scope '2 ends
    if(a == 10){ // scope '3 starts
      int c = 30;
    } // scope '3 ends
    return b; // This fails because it's not in scope
} // scope '1 ends
```

\normalsize

## Why should I care about freeing memory? Is it really a problem?

- If your system has infinite memory, you don't need to worry. However, since memory is finite, you must take care.
  \pause
- If one program uses up all the memory, other programs that require memory won't be able to function properly.
  \pause
- Your program may \textcolor{red}{crash} if it requests more memory than the operating system can provide.
  \pause
- Memory leaks can have a significant impact on long-running programs such as \texttt{web servers, editors, and IDEs}.

# Ways to manage memory

We have two ways to do memory management.

\pause

- **Manual Memory Management** : Languages such as C, C++, Rust, etc have this

- **Automatic Memory Management**: Languages such as Python, Java, Go,
  JavaScript, Swift, etc have this.

# Manual Memory Management

## Scenarios where you can go wrong

::: columns

:::: {.column width=40%}

\vspace{30pt}
\tiny

```cpp
// NOTE: this is a dumb example to show where things can go wrong,
// I don't actually write code like this
int* allocate_and_throw_exn_if_n_lt_10(int n){
   int *arr = malloc(n*sizeof(int));
   if (n < 10){
       throw runtime_error("n < 10");
   }
   return arr;
}
int main(){
    try {
        auto *arr = allocate_and_throw_exn_if_n_lt_10(2);
        free(arr);
    } catch(const std::runtime_error &e){
        cout << "Error:" <<e.what() << endl;
    }
}
```

\normalsize

::::

:::: {.column width=60%}

![Flow for the leaking code](images/mem_management_leak_scenario1.png){width=70%}

![Memory Leak Detected by address sanitizer](images/./leak_detected.png){width=90%}

::::

:::

## How to fix it??

- \textcolor{red}{DON'T WRITE DUMB CODE LIKE I DID}

- More high level language(than C) like C++, Rust provide us with smart ways to manage memory

- They come built-in with smart pointer types like \texttt{unique\textunderscore ptr} (C++)

## Fixing the code with smart pointer

\scriptsize

::: columns

:::: column

```cpp
std::unique_ptr<int[]> allocate_and_throw_exn_if_n_lt_10(int n){
   auto *arr = make_unique<int[]>(new int[n]);
   if (n < 10){
       throw runtime_error("n < 10");
   }
   return arr;
}
int main(){
    try {
        auto arr = allocate_and_throw_exn_if_n_lt_10(2);
    } catch(const std::runtime_error &e){
        cout << "Error:" <<e.what() << endl;
    }
}
```

\normalsize

\pause

::::

:::: column

\vspace{90pt}

\begin{center}

\large
\textbf{\textcolor{red}{What the hell just happened??}}

\normalsize

We're not even freeing anything?? How does this work?

\end{center}

::::

:::

## How do smart pointers work?

::: columns

:::: { .column width=30%}

\vspace{20pt}

- Uses **scope** to track lifetime of a pointer(scopes mentioned in [previous section](#what-is-this-scope-thing))

\pause

- C++ uses \texttt{destructors} to run code when an object goes out of scope. (due to RAII in C++)

\pause

::::

:::: { .column width=70%}

### What is RAII in C++?

![RAII](images/raii.png)

![Destructor call added automatically](images/./destructor.png)

::::

:::

## Let's make our own unique_ptr

::: columns

:::: column

\scriptsize

```cpp
#include <iostream>
using namespace std;
class int_ptr{
    int* x ;
public:
    int_ptr(int x): x{new int(x)}{}
    ~int_ptr(){
        delete x;
    }
    int& operator*(){
        return *x;
    }
};
int main(){
    int_ptr one(1);
    cout << *one << endl;
}
```

\normalsize

::::

:::: column

\vspace{30pt}

![int_ptr working without any leaks](images/./int_ptr_working.png)

::::

:::

## Is unique_ptr the only smart pointer??

\huge
\centering\textbf{\textcolor{red}{ NO }}
\normalsize

## Isn't unique_ptr perfect already? Why would I need anything else?

- Problem with \texttt{unique\textunderscore ptr} is that it can have only one owner.

\pause

::: columns

:::: { .column width=30%}

### Case in Point

- A \texttt{unix file descriptor}

\pause

- A file descriptor can have multiple owners. It should only be freed when all the owners go out of scope.

::::

:::: { .column width=70%}

\pause

![File Descriptor with unique_ptr(the code is very badðŸ¥²)](images/./fd.png)

::::

:::

\pause

\centering {\textbf{Not possible to model this correctly }}

\pause

\centering {\textbf{That's why we need more }}

# Introduction to Automatic Memory Management

# Reference Counting

# Trace Based Collection

# Which is better?(Automatic Memory Management or Manual Management

# Advanced Topics in Garbage Collection

- Incremental GC

- Parallel and Concurrent GC

- Precise and Conservative Garbage Collectors

- Reducing GC pause\*

# References

- [Some presentation on GC, Grinnel college](https://rebelsky.cs.grinnell.edu/Courses/CS302/99S/Presentations/GC/)
