#+title: Understanding Memory Management
#+author: Dipesh Kafle
#+DATE:  15 April 2023
#+STARTUP: inlineimages
#+REVEAL_ROOT: https://cdn.jsdelivr.net/npm/reveal.js
#+REVEAL_MAX_SCALE: 0.5

* Prerequisites

** Memory Layout

#+CAPTION: A program's memory segments roughly classified
#+NAME:   fig:memory-segment
#+ATTR_ORG: :width 500 :height 500
[[file:memory.png]]

- A program's memory segments roughly classified
- In practice, the stack grows towards lower addresses, the heap towards
  higher(the diagram has it the other way around, but that doesn't matter).
- What are all these things ??
- We are mainly concerned withe the stack and the heap for the purpose of this talk


** Code and Static segments

- Code :: The size of the generated target code is fixed at compile time, so the compiler can
  place the executable target code in a statically determined area Code, usually in the low end of memory.

- Static :: The size of some program data objects, such as global constants,
  and data generated by the compiler that may be known at compile time, and these data objects can be placed
  in another statically determined area called Static.

#+REVEAL: split:t

#+begin_src c
const char* s = "Lorem Ipsum something something";
int main(){
    const char* string_arr[] = {"Made", "with", "love", "by", "Delta", "Force"};
    return 0;
}
#+end_src

All the strings used in the above code segment are stored in static section, while the
instructions generated for the program will be in code section.

**  Stack and Stack Allocation

- The stack will store things such as return address from a function call, local variables, etc.

#+begin_src c
int main(){
    int a = 10; // This is doing stack allocation
    int b = 20;
    int arr[2] = {1,2};
    return 0;
}
#+end_src

#+REVEAL: split

#+ATTR_ORG: :width 500 :height 500
[[file:stack_layout.png]]


** Heap and Heap Allocation

* Introduction to Memory Management


* Why should you care

* Ways to manage memory

* Manual Memory Management

* Introduction to Automatic Memory Management

* Reference Counting

* Trace Based Collection

* Which is better?(Automatic Memory Management or Manual Management

#+begin_src ocaml
#+end_src


* Advanced Topics in Garbage Collection
- Incremental GC
- Parallel and Concurrent GC
- Precise and Conservative Garbage Collectors
- Reducing GC pause*

* Reference
